"""
author: James Kelly
date: 09/28/2023
uses object detection model on images generated by a text-to-image model 
to evaluate the quality of the text-to-image model by comparing the object 
counts in the prompt vs the generated image
"""

from typing import Any, Dict, List, Optional, Tuple
from utils import parse_objects_and_quantities
from transformers import pipeline
from pathlib import Path
import json
import os


def evaluate(img_folder: str, detector: Optional[Any] = None) -> Tuple[Dict[str, float], Dict[str, float]]:
    ioqms = dict(dict())
    if detector is None:
         detector = pipeline("object-detection", model="facebook/detr-resnet-50")
         
    for img_file in os.listdir(img_folder):
        prompt = ' '.join(Path(img_file).stem.split('_'))
        img_path = os.path.join(img_folder, img_file)
        detected_quants = get_obj_quants(detector(img_path))
        expected_quants = parse_objects_and_quantities(prompt)
        h_ioqm = hard_ioqm(expected_quants, detected_quants)
        s_ioqm = soft_ioqm(expected_quants, detected_quants)
        ioqms[prompt] = dict()
        ioqms[prompt]['hard_ioqm'] = h_ioqm
        ioqms[prompt]['soft_ioqm'] = s_ioqm
    
    return ioqms


def get_obj_quants(result: List[Dict[str, float]]) -> Dict[str, float]:
  obj_quants = dict()
  for res in result:
    obj_quants[res['label']] = obj_quants.get(res['label'], 0) + 1

  return obj_quants
    


def check_object(obj: str, detected_obs: Dict[str, int]) -> Optional[str]:
  for det_obj in detected_obs:
    if len(obj) > len(det_obj):
      if obj.startswith(det_obj):
        return det_obj
    if det_obj.startswith(obj):
        return det_obj

  return None


def hard_ioqm(expected_obs: Dict[str, int], detected_obs: Dict[str, int]) -> float:
    """
      desc: calculates num of objects with correct quantities / num objects, 0 to 1.0
      expected = dict_items([('skis', 1), ('snowboard', 3), ('backpack', 2)])
      detected = dict_items([('snowboards', 3), ('backpacks', 5), ('ties', 3)])
      hard_ioqm = 1 / 3 = 0.3333
    """
    num_exp_objects = float(len(expected_obs)) 
    assert num_exp_objects > 0, "no expected objects" # avoids div by 0

    ioqm = 0.0
    for obj, exp_quant in expected_obs.items():
        det_obj = check_object(obj, detected_obs)
        if det_obj is None:
            continue
        if detected_obs[det_obj] != exp_quant:
            continue
        ioqm += 1
    return ioqm / num_exp_objects




def soft_ioqm(expected_obs: Dict[str, int], detected_obs: Dict[str, int]) -> float:
    """
        desc: calculates average num of objects / num expected objects, 0 to 1.0
        expected = dict_items([('skis', 1), ('snowboard', 3), ('backpack', 2)])
        detected = dict_items([('snowboards', 5), ('backpacks', 5), ('ties', 3)])
        soft_ioqm = 0/1 + 3/5 + 2/5 = 0.6 / 3 = 0.2
    """
    num_exp_objects = float(len(expected_obs)) 
    assert num_exp_objects > 0, "no expected objects" # avoids div by 0
    
    ioqm = 0.0
    for obj, exp_quant in expected_obs.items():
        det_obj = check_object(obj, detected_obs)
        if det_obj is None:
            continue
        ioqm += detected_obs[det_obj] / float(exp_quant)
    return ioqm / num_exp_objects


def save_scores_jsonl(ioqm_scores: Dict[str, Dict[str, float]], save_path: Path) -> None:
  with open(save_path, 'w') as fp:
    for p, scores in ioqm_scores.items():
      json.dump({p: scores}, fp)
      fp.write('\n')
